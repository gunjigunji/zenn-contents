---
title: "キラーナンプレRTAチャレンジ"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["sudoku", "killer_sudoku"]
published: false
---


## はじめに
[^MyOpinion1]:難易度は個人の主観です。
[^MyOpinion2]:諸説あります。

みなさんは"キラーナンプレ"というゲームをご存知でしょうか？
これは、通常のナンプレにひねりを加えたとても難しいゲームです[^MyOpinion1]。

難しいと言われると解きたくなるのが人の性、新卒研修の傍ら、キラーナンプレのRTAが同期の間でにわかに流行っていました[^MyOpinion2]。

例に漏れず私も挑戦していたのですが、RTAどころか解くこともままならない状況でした。
悔しい。

そこで、同期のはだくん、いいだくんに協力してもらい、キラーナンプレを自動で解くwebアプリケーションの開発に取り組みました。

本記事ではその取り組みを紹介したいと思います。



## キラーナンプレ

<!-- キラーナンプレとは、通常のナンプレ[^NumberPlace] -->
<!-- （別名：数独[^Sudoku]）に加えていくつか条件がついたゲームです。 -->
<!-- （参考: https://sudoku.com/killer ） -->

[^NumberPlace]:ナンバープレイスの略
[^Sudoku]:数字は独身に限るの略


キラーナンプレを説明する前に、その元ネタである"ナンプレ"[^NumberPlace]（別名：数独[^Sudoku]）についておさらいしておきます。

ナンプレとは、9×9のマス目（ボードと呼ぶ）を考え、そのマスを次のルールに従って1から9までの整数で埋めるゲームです。

基本ルール: 
- 各マスは1から9までの整数のいずれか一つを含む
- 各縦の9マスは1から9の整数を一つずつ含む
- 各横の9マスは1から9の整数をそれぞれ一つずつ含む
- 各3×3のマス目（ブロックと呼ぶ）は1から9の整数をそれぞれ一つずつ含む

ボード内のいくつかのマスにはゲームの開始時点で既に数字が入っており、その数字と上記のルールを手がかりにボード内全てのマスに数字を埋めていきます。(Fig.1参照)

```
この辺に画像
![](https://画像のURL)
*キャプション*
```

これがナンプレです。

一方、キラーナンプレでは、従来のナンプレのルールに加えて新たに"ケージ"についてのルールが導入されます。（参考: https://sudoku.com/killer ）

ケージとは、ボード内で点線で囲まれた数マスからなる領域です。
ゲーム開始時点で、各ケージの左上隅にはそれぞれ数字が与えられており、次のルールに従いながら数字を埋めます。

追加ルール:
- 各ケージ内のマスに入る数字の合計が各ケージに与えられた数字と等しくなる

これがキラーナンプレです。特にマスの初期値が一つも与えられない問題は難易度が非常に高いです。
そこで、今回は初期値なしの高難易度版に挑みます。[^high_level]
[^hign_level]:なお、今回作成したアプリは初期値がある場合のキラーナンプレにも対応しています。

```
この辺に画像
![](https://画像のURL)
*キャプション*
```



## 定式化

今回キラーナンプレを解くあたって数理最適化によるアプローチを試みました。
<!-- 理由は研修や新卒勉強会で勉強したので使ってみたかったからです。 -->
定式化には次の記事を参考にさせていただきました。
- @[card](https://jp.mathworks.com/help/optim/ug/sudoku-puzzles-problem-based.html)
- @[card](https://yshr10ic.com/2023/01/16/sudoku-solver-pulp/)

これらを参考に、ルールを制約条件とした整数計画で定式化することで解けそうです。ということで定式化しました。


### 目的関数
今回は最小化・最大化する問題ではないため、目的関数は定数項$0$とします。

### 制約条件

簡単のため、初期値が空欄のマスには$0$が与えられているものとします。
また、下記のように記号を定義します:
- マスに入る数字の初期値の集合: $N_0=\{0,1,2,\dots,9\}$
- マスに入りうる数字の集合: $N=\{1,2,\dots,9\}$
- マスのx座標の集合: $X=\{1,2,\dots,9\}$
- マスのy座標の集合: $Y=\{1,2,\dots,9\}$
- ボックス番号の集合: $B=\{1,2,\dots,9\}$
- ボックス$b\in B$に含まれるマスの座標の集合: $V_b$
- ケージ番号の集合: $C=\{1,2,\dots\}$
- ケージ$c\in C$に含まれるマスの座標の集合: $V_c$

また、解を表現するためにバイナリ変数$a_{xyn}=\{0,1\}$を導入します。
ここで、
$x, y$ $(x\in X, y\in Y)$はマスの座標添字、$n\in N$はマスに入りうる数字の添字です。(Fig.3参照)
すなわち、
座標$(x,y)$のマスに数字$n$がある場合には$a_{xyn}=1$であり、それ以外は0の値をとります。
```
この辺に画像
![](https://画像のURL)
*キャプション*
```

このバイナリ変数を用いて、キラーナンプレのルールを下記のように制約式として表します: 
- マスの数字の初期値$n_0\in N_0$に対応する変数$a_{xyn_0}$の値
    \begin{align}
    a_{xyn} =
    \delta_{n n_0}
    \quad
    (x\in X,~y\in Y,~n_0\in N_0)
  \end{align}
- 一つのマスに一つの数字が入る
    \begin{align}
      \sum_{n\in N} a_{xyn} = 1 \quad ( x\in X,~y\in Y )
    \end{align}
- 横のマスに入る数字が重複しない
    \begin{align}
      \sum_{x\in X}  a_{xyn} = 1
      \quad
      (y\in Y,~n\in N)
    \end{align}
- 縦のマスに入る数字が重複しない
    \begin{align}
      \sum_{y\in Y} a_{xyn} = 1
      \quad
      (x\in X,~n\in N)
    \end{align}
- ブロックに入る数字が重複しない
    \begin{align}
      \sum_{(x,y)\in V_b} a_{xyn} = 1
      \quad
      (b\in B,~n\in N)
    \end{align}
- ケージ内の数字合計がケージに与えられた数字に等しい
    \begin{align}
      \sum_{(x, y)\in V_c}\sum_{n\in N}
      a_{xyn}\cdot n
      =
      n_c
      \quad
      (c\in C)
    \end{align}
    ただし、$n_c$はケージ$c\in C$に与えられた数字を表す。


## アプリケーション化
ここまでで定式化が終わりました。あとはpython等で実装して実際の問題に対して解を求めれば良い訳です。
そこで、今回は[PuLP](https://pypi.org/project/PuLP/)を用いて実装し、いくつかのナンプレ問題に対して無事解を求められることを確認しました。(最終的なコードはXXを参照。)

しかし、ここで**致命的な課題**が判明しました。

それは、ナンプレの盤面情報（マスの初期値やケージの条件）を手で入力するのに非常に時間がかかってしまうというものです。
<!-- 解を求めるために必要なナンプレの盤面情報を手入力していたのですが、そこに非常に時間がかかってしまっていました。 -->
実際、**盤面を手入力する時間する時間が自力で問題を解く時間とコンパラ**になっていました。
これではせっかく解を求めても、キラーナンプレRTAで負けてしまいます。

そこで、
同期のはだくんといいだくんに協力してもらい、
盤面情報の入力を容易にし、サクッと解を求めてくれるキラーナンプレソルバーアプリケーションの作成に取り組みました。

---
以降羽田くん、飯田くんにパスという感じでどうでしょう？
