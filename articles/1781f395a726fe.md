---
title: "キラーナンプレRTAチャレンジ"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["Sudoku", "KillerSudoku"]
published: false
---
[^MyOpinion1]:難易度は個人の主観です。
[^MyOpinion2]:諸説あります。
[^HignLevel]:なお、今回作成したアプリは初期値がある場合のキラーナンプレにも対応しています。



## はじめに
みなさんは"キラーナンプレ"というゲームをご存知でしょうか？これは、通常のナンプレにひねりを加えたとても難しいゲームです[^MyOpinion1]。

難しいと言われると解きたくなるのが人の性、会社の同期の間でキラーナンプレのRTAがにわかに流行っていました[^MyOpinion2]。例に漏れず私も挑戦していたのですが、RTAどころか解くこともままならない状況でした。悔しい。

そこで、同期のはだくん、いいだくんに協力してもらい、キラーナンプレを自動で解くwebアプリケーションの開発に取り組みました。

本記事ではその取り組みを紹介したいと思います。
なお本記事はぐんじ、はだくん、いいだくんの3人で執筆しており、各々の担当箇所は次の通りです。
- ぐんじ: はじめに〜定式化
- はだくん: XXX
- いいだくん: 光学文字認識（OCR）パート



<!-- （参考: https://sudoku.com/killer ） -->

## キラーナンプレとは
キラーナンプレを説明する前に、その元ネタである"ナンプレ"（別名：数独）についておさらいしておきます。

ナンプレとは、9×9のマス目（ボードと呼ぶ）を考え、そのマスを次のルールに従って1から9までの整数で埋めるゲームです。

:::message
**基本ルール**
- 各マスは1から9までの整数のいずれか一つを含む
- 各縦の9マスは1から9の整数を一つずつ含む
- 各横の9マスは1から9の整数をそれぞれ一つずつ含む
- 各3×3のマス目（ブロックと呼ぶ）は1から9の整数をそれぞれ一つずつ含む
:::

ボード内のいくつかのマスにはゲームの開始時点で既に数字が入っており、その数字と上記のルールを手がかりにボード内全てのマスに数字を埋めていきます。(Fig.1参照)

![](/images/sudoku.png)
*Figure.1 ナンプレの問題例。画像は https://sudoku.com/jp より抜粋後一部加工。*

一方、キラーナンプレでは、従来のナンプレのルールに加えて新たに"ケージ"についてのルールが導入されます。（参考: https://sudoku.com/killer ）

ケージとは、ボード内で点線で囲まれた数マスからなる領域です。
ゲーム開始時点で、各ケージの左上隅にはそれぞれ数字が与えられており、次のルールに従いながら数字を埋めます。

:::message
**追加ルール**
- 各ケージ内のマスに入る数字の合計が各ケージに与えられた数字と等しくなる
:::

これがキラーナンプレです。特にマスの初期値が一つも与えられない問題は難易度が非常に高いです。そこで、今回は初期値なしの高難易度版に挑みます[^HignLevel]。

![](/images/killer_sudoku.png)
*Figure.2 キラーナンプレの問題例。画像は https://sudoku.com/jp より抜粋後一部加工。*


## 定式化

今回キラーナンプレを解くあたって数理最適化によるアプローチを試みました。
定式化には次の記事を参考にさせていただきました。
@[card](https://jp.mathworks.com/help/optim/ug/sudoku-puzzles-problem-based.html)
@[card](https://yshr10ic.com/2023/01/16/sudoku-solver-pulp/)
どうやら、ルールを制約条件とした整数計画で定式化することで解けそうです。ということで次のように定式化しました。

**目的関数**
今回は最小化・最大化する問題ではないため、目的関数は定数項$0$とします。

**制約条件**
簡単のため、初期値が空欄のマスには$0$が与えられているものとします。
また、記号を次のように定義します。
- マスに入る数字の初期値の集合: $N_0=\{0,1,2,\dots,9\}$
- マスに入りうる数字の集合: $N=\{1,2,\dots,9\}$
- マスのx座標の集合: $X=\{1,2,\dots,9\}$
- マスのy座標の集合: $Y=\{1,2,\dots,9\}$
- ボックス番号の集合: $B=\{1,2,\dots,9\}$
- ボックス$b\in B$に含まれるマスの座標の集合: $V_b$
- ケージ番号の集合: $C=\{1,2,\dots\}$
- ケージ$c\in C$に含まれるマスの座標の集合: $V_c$

加えて、解を表現するためにバイナリ変数$a_{xyn}=\{0,1\}$を導入します。ここで、$x, y$ $(x\in X, y\in Y)$はマスの座標添字、$n\in N$はマスに入りうる数字の添字です。(Fig.3参照) 
座標$(x,y)$のマスに数字$n$がある場合には$a_{xyn}=1$であり、それ以外は0の値をとります。
このバイナリ変数を用いて、キラーナンプレのルールを次のような制約式で表しました。 
- マスの数字の初期値$n_0\in N_0$に対応する変数$a_{xyn_0}$の値

    $$
    a_{xyn} = \delta_{n n_0} \quad (x\in X,~y\in Y,~n_0\in N_0)
    $$

- 一つのマスに一つの数字が入る

    $$
      \sum_{n\in N} a_{xyn} = 1 \quad ( x\in X,~y\in Y )
    $$

- 横のマスに入る数字が重複しない

    $$
      \sum_{x\in X}  a_{xyn} = 1
      \quad
      (y\in Y,~n\in N)
    $$

- 縦のマスに入る数字が重複しない

    $$
      \sum_{y\in Y} a_{xyn} = 1
      \quad
      (x\in X,~n\in N)
    $$

- ブロックに入る数字が重複しない

    $$
      \sum_{(x,y)\in V_b} a_{xyn} = 1
      \quad
      (b\in B,~n\in N)
    $$

- ケージ内の数字合計がケージに与えられた数字に等しい
    
    $$
      \sum_{(x, y)\in V_c}\sum_{n\in N}
      a_{xyn}\cdot n
      =
      n_c
      \quad
      (c\in C)
    $$

    ただし、$n_c$はケージ$c\in C$に与えられた数字を表す。
![](/images/sudoku_coordinate.png)
*Figure.3 座標の取り方。画像は https://sudoku.com/jp より抜粋後一部加工。*


<!-- ## アプリケーション化へ -->
ここまでで定式化が終わりました。あとはpython等で実装して実際の問題に対して解を求めれば良い訳です。
そこで、今回は[PuLP](https://pypi.org/project/PuLP/)を用いて実装し、いくつかのナンプレ問題に対して無事解を求められることを確認しました。(最終的なコードは [Bitbucketリポジトリ](https://bitbucket.org/atsuhiro-hada/sudoku_rta/src/master/) を参照。)

しかし、ここで**致命的な課題**が判明しました。実は、ナンプレの盤面情報（マスの初期値やケージの条件）を手で入力する作業に非常に時間がかかってしまっていたのです。
実際、**盤面を手入力する時間する時間が自力で問題を解く時間とコンパラ**になっていました。これではせっかく解を求めても、キラーナンプレRTAで負けてしまいます。

そこで、同期のはだくんといいだくんに協力してもらい、盤面情報の入力を容易にし、サクッと解を求めてくれるキラーナンプレソルバーアプリケーションの作成に取り組みました。

:::message alert 
以降羽田くん、飯田くんにパスという感じでどうでしょう？
あと上で羽田くんのリポジトリのリンク載せてるけどマズかったら教えてください〜
:::



## 光学文字認識（OCR）による左上認識
:::message
**左上認識における目標**：ケージの総和を示す数値（左上数値）を間違いなく認識する
:::
大まかなフロー図は以下です。
![](/images/ocr_overall.png =500x)
各番号での詳細は後述します。

### ①.数値領域の抽出
左上の数値領域のみを抽出する。
数値領域は毎回ほとんど同じ位置に1桁もしくは2桁の数値で現れるため、2桁の領域分をピクセルで指定し、クロップしました。
![](/images/ocr_region_number.png =500x)

### ②.桁数の判定および各桁での数値領域の抽出
今回は、2桁の数値はOCRでは認識できない状況（後述）だったため、2桁の数値を10の位と1の位で領域を分割する必要がありました。
また画像をよく見ると、1桁の数値は10の位の位置に現れていたので、1の位に該当する領域に数値があるか否かを判定できれば、数値の桁数判定はできそうだと考えました💡
具体的には、画像全体を大津法で2値化し、1の位の領域に数値と同じ画素値のピクセルが10%以上存在する場合は2桁の数値、10%未満の場合は1桁の数値として判定しました。
![](/images/ocr_divide_number.png =500x)

### ③.OCRにて各桁の数値認識
各桁の画像に対して、`pyOCR`を用いてOCR数値認識を行いました。
https://gitlab.gnome.org/World/OpenPaperwork/pyocr

OCRの設定は以下で行いました。
```
tools = pyocr.get_available_tools()
tool = tools[0]
# 画像中には単一のテキストブロックが存在する設定
builder = pyocr.builders.DigitBuilder(tesseract_layout=6)
# 文字の候補リストはの数値のみ（0-9）
builder.tesseract_configs.append('tessedit_char_whitelist=0123456789')​
```
:::message alert
**OCRで画像から直接数値を認識しなかった理由**
これは完全に技量不足感が否めないですが、どうしても2桁の数値の認識ができませんでした。
* よくあったOCRの間違い：`1`と`7`、`4`と`9`、`6`と`8`の区別ができない
:::

### ④.各桁の画像データから数値を予測するモデルを構築
OCRだけではうまくいかなかったので、最終手段としてゴリゴリに過学習させた機械学習モデルを用いて数値検出する力技を用いました。
具体的な方法は以下です。
* 20枚の盤面画像から数値領域、さらに各桁ごとの画像を用意し、OCRにて教師ラベルを付与する
* 画像を1次元配列に変換し、SVMにて学習
