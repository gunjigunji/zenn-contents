---
title: "キラーナンプレRTAチャレンジ"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["sudoku", "killer_sudoku"]
published: false
---


## はじめに
[^MyOpinion1]:難易度は個人の主観です。
[^MyOpinion2]:諸説あります。

みなさんは"キラーナンプレ"というゲームをご存知でしょうか？
これは、通常のナンプレにひねりを加えたとても難しいゲームです[^MyOpinion1]。

難しいと言われると解きたくなるのが人の性、新卒研修の傍ら、キラーナンプレのRTAが同期の間でにわかに流行っていました[^MyOpinion2]。

例に漏れず私も挑戦していたのですが、RTAどころか解くこともままならない状況でした。
悔しい。

そこで、同期のはだくん、いいだくんに協力してもらい、キラーナンプレを自動で解くwebアプリケーションの開発に取り組みました。

本記事ではその取り組みを紹介したいと思います。



## キラーナンプレ

<!-- キラーナンプレとは、通常のナンプレ[^NumberPlace] -->
<!-- （別名：数独[^Sudoku]）に加えていくつか条件がついたゲームです。 -->
<!-- （参考: https://sudoku.com/killer ） -->

[^NumberPlace]:ナンバープレイスの略
[^Sudoku]:数字は独身に限るの略


キラーナンプレを説明する前に、その元ネタである"ナンプレ"[^NumberPlace]（別名：数独[^Sudoku]）についておさらいしておきます。

ナンプレとは、9×9のマス目（ボードと呼ぶ）を考え、そのマスを次のルールに従って1から9までの整数で埋めるゲームです。

基本ルール: 
- 各マスは1から9までの整数のいずれか一つを含む
- 各縦の9マスは1から9の整数を一つずつ含む
- 各横の9マスは1から9の整数をそれぞれ一つずつ含む
- 各3×3のマス目（ブロックと呼ぶ）は1から9の整数をそれぞれ一つずつ含む

ボード内のいくつかのマスにはゲームの開始時点で既に数字が入っており、その数字と上記のルールを手がかりにボード内全てのマスに数字を埋めていきます。(Fig.1参照)

```
この辺に画像
![](https://画像のURL)
*キャプション*
```

これがナンプレです。

一方、キラーナンプレでは、従来のナンプレのルールに加えて新たに"ケージ"についてのルールが導入されます。（参考: https://sudoku.com/killer ）

ケージとは、ボード内で点線で囲まれた数マスからなる領域です。
ゲーム開始時点で、各ケージの左上隅にはそれぞれ数字が与えられており、次のルールに従いながら数字を埋めます。

追加ルール:
- 各ケージ内のマスに入る数字の合計が各ケージに与えられた数字と等しくなる

これがキラーナンプレです。特にマスの初期値が一つも与えられない問題は難易度が非常に高いです。
そこで、今回は初期値なしの高難易度版に挑みます。[^high_level]
[^hign_level]:なお、今回作成したアプリは初期値がある場合のキラーナンプレにも対応しています。

```
この辺に画像
![](https://画像のURL)
*キャプション*
```



## 定式化

今回キラーナンプレを解くあたって数理最適化によるアプローチを試みました。
<!-- 理由は研修や新卒勉強会で勉強したので使ってみたかったからです。 -->
定式化には次の記事を参考にさせていただきました。
- @[card](https://jp.mathworks.com/help/optim/ug/sudoku-puzzles-problem-based.html)
- @[card](https://yshr10ic.com/2023/01/16/sudoku-solver-pulp/)

これらを参考に、ルールを制約条件とした整数計画で定式化することで解けそうです。ということで定式化しました。


### 目的関数
今回は最小化・最大化する問題ではないため、目的関数は定数項$0$とします。

### 制約条件

簡単のため、初期値が空欄のマスには$0$が与えられているものとします。
また、下記のように記号を定義します:
- マスに入る数字の初期値の集合: $N_0=\{0,1,2,\dots,9\}$
- マスに入りうる数字の集合: $N=\{1,2,\dots,9\}$
- マスのx座標の集合: $X=\{1,2,\dots,9\}$
- マスのy座標の集合: $Y=\{1,2,\dots,9\}$
- ボックス番号の集合: $B=\{1,2,\dots,9\}$
- ボックス$b\in B$に含まれるマスの座標の集合: $V_b$
- ケージ番号の集合: $C=\{1,2,\dots\}$
- ケージ$c\in C$に含まれるマスの座標の集合: $V_c$

また、解を表現するためにバイナリ変数$a_{xyn}=\{0,1\}$を導入します。
ここで、
$x, y$ $(x\in X, y\in Y)$はマスの座標添字、$n\in N$はマスに入りうる数字の添字です。(Fig.3参照)
すなわち、
座標$(x,y)$のマスに数字$n$がある場合には$a_{xyn}=1$であり、それ以外は0の値をとります。
```
この辺に画像
![](https://画像のURL)
*キャプション*
```

このバイナリ変数を用いて、キラーナンプレのルールを下記のように制約式として表します: 
- マスの数字の初期値$n_0\in N_0$に対応する変数$a_{xyn_0}$の値
    \begin{align}
    a_{xyn} =
    \delta_{n n_0}
    \quad
    (x\in X,~y\in Y,~n_0\in N_0)
  \end{align}
- 一つのマスに一つの数字が入る
    \begin{align}
      \sum_{n\in N} a_{xyn} = 1 \quad ( x\in X,~y\in Y )
    \end{align}
- 横のマスに入る数字が重複しない
    \begin{align}
      \sum_{x\in X}  a_{xyn} = 1
      \quad
      (y\in Y,~n\in N)
    \end{align}
- 縦のマスに入る数字が重複しない
    \begin{align}
      \sum_{y\in Y} a_{xyn} = 1
      \quad
      (x\in X,~n\in N)
    \end{align}
- ブロックに入る数字が重複しない
    \begin{align}
      \sum_{(x,y)\in V_b} a_{xyn} = 1
      \quad
      (b\in B,~n\in N)
    \end{align}
- ケージ内の数字合計がケージに与えられた数字に等しい
    \begin{align}
      \sum_{(x, y)\in V_c}\sum_{n\in N}
      a_{xyn}\cdot n
      =
      n_c
      \quad
      (c\in C)
    \end{align}
    ただし、$n_c$はケージ$c\in C$に与えられた数字を表す。


## アプリケーション化
ここまでで定式化が終わりました。あとはpython等で実装して実際の問題に対して解を求めれば良い訳です。
そこで、今回は[PuLP](https://pypi.org/project/PuLP/)を用いて実装し、いくつかのナンプレ問題に対して無事解を求められることを確認しました。(最終的なコードはXXを参照。)

しかし、ここで**致命的な課題**が判明しました。

それは、ナンプレの盤面情報（マスの初期値やケージの条件）を手で入力するのに非常に時間がかかってしまうというものです。
<!-- 解を求めるために必要なナンプレの盤面情報を手入力していたのですが、そこに非常に時間がかかってしまっていました。 -->
実際、**盤面を手入力する時間する時間が自力で問題を解く時間とコンパラ**になっていました。
これではせっかく解を求めても、キラーナンプレRTAで負けてしまいます。

そこで、
同期のはだくんといいだくんに協力してもらい、
盤面情報の入力を容易にし、サクッと解を求めてくれるキラーナンプレソルバーアプリケーションの作成に取り組みました。

---
以降羽田くん、飯田くんにパスという感じでどうでしょう？



## 光学文字認識（OCR）による左上認識
:::message
**左上認識における目標**：ケージの総和を示す数値（左上数値）を間違いなく認識する
:::
大まかなフロー図は以下です。
![](/images/ocr_overall.png =500x)
各番号での詳細は後述します。

### ①.数値領域の抽出
左上の数値領域のみを抽出する。
数値領域は毎回ほとんど同じ位置に1桁もしくは2桁の数値で現れるため、2桁の領域分をピクセルで指定し、クロップしました。
![](/images/ocr_region_number.png =500x)

### ②.桁数の判定および各桁での数値領域の抽出
今回は、2桁の数値はOCRでは認識できない状況（後述）だったため、2桁の数値を10の位と1の位で領域を分割する必要がありました。
また画像をよく見ると、1桁の数値は10の位の位置に現れていたので、1の位に該当する領域に数値があるか否かを判定できれば、数値の桁数判定はできそうだと考えました💡
具体的には、画像全体を大津法で2値化し、1の位の領域に数値と同じ画素値のピクセルが10%以上存在する場合は2桁の数値、10%未満の場合は1桁の数値として判定しました。
![](/images/ocr_divide_number.png =500x)

### ③.OCRにて各桁の数値認識
各桁の画像に対して、`pyOCR`を用いてOCR数値認識を行いました。
https://gitlab.gnome.org/World/OpenPaperwork/pyocr

OCRの設定は以下で行いました。
```
tools = pyocr.get_available_tools()
tool = tools[0]
# 画像中には単一のテキストブロックが存在する設定
builder = pyocr.builders.DigitBuilder(tesseract_layout=6)
# 文字の候補リストはの数値のみ（0-9）
builder.tesseract_configs.append('tessedit_char_whitelist=0123456789')​
```
:::message alert
**OCRで画像から直接数値を認識しなかった理由**
これは完全に技量不足感が否めないですが、どうしても2桁の数値の認識ができませんでした。
* よくあったOCRの間違い：`1`と`7`、`4`と`9`、`6`と`8`の区別ができない
:::

### ④.各桁の画像データから数値を予測するモデルを構築
OCRだけではうまくいかなかったので、最終手段としてゴリゴリに過学習させた機械学習モデルを用いて数値検出する力技を用いました。
具体的な方法は以下です。
* 20枚の盤面画像から数値領域、さらに各桁ごとの画像を用意し、OCRにて教師ラベルを付与する
* 画像を1次元配列に変換し、SVMにて学習